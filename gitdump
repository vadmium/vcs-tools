#! /usr/bin/env python2
from __future__ import print_function

from subvertpy.ra import (RemoteAccess, Auth, get_username_provider)
from subvertpy.delta import apply_txdelta_window
from subvertpy.properties import (
    PROP_REVISION_DATE,
    PROP_REVISION_AUTHOR,
    PROP_REVISION_LOG,
)
from sys import (stderr, argv)
from functools import partial
from time import strptime
from calendar import timegm
from io import SEEK_END

def nop(*args, **kw):
    pass

class Function(object):
    def __init__(self):
        self.__name__ = type(self).__name__
    def __get__(self, obj, cls):
        if obj is None:
            return self
        return Binding(self, obj)
class Binding:
    def __init__(self, func, obj):
        self.func = func
        self.obj = obj
    def __call__(self, *args, **kw):
        return self.func(self.obj, *args, **kw)

class traced(Function):
    def __init__(self, func, name=None, abbrev=set()):
        self.func = func
        self.name = name
        self.abbrev = abbrev
        
        if self.name is None:
            self.name = func.__name__
    
    def __call__(self, *args, **kw):
        print(self.name, end="(", file=stderr)
        
        for (k, v) in enumerate(args):
            if k:
                print(", ", end="", file=stderr)
            if k in self.abbrev:
                v = "..."
            else:
                v = repr(v)
            print(v, end="", file=stderr)
        
        comma = bool(args)
        for (k, v) in kw.items():
            if comma:
                print(", ", end="", file=stderr)
            if k in self.abbrev:
                v = "..."
            else:
                v = repr(v)
            print("{}={}".format(k, v), end="", file=stderr)
            comma = True
        
        print(end=") ", file=stderr)
        stderr.flush()
        ret = self.func(*args, **kw)
        if "return" in self.abbrev:
            v = "..."
        else:
            v = repr(ret)
        print("->", v, file=stderr)
        return ret

def trace(func, *args, **kw):
    return traced(func)(*args, **kw)
def Tracer(name):
    return traced(nop, name=name)

def main(_, dump, url, end_rev):
    end_rev = int(end_rev)
    repo = Record(files=dict())
    
    with open(dump, "w+b") as repo.dump:
        # Auth stuff avoids the following error for diffs on local (file://)
        # URLs: "No provider registered for 'svn.username' credentials"
        auth = Auth((get_username_provider(),))
        
        ra = trace(RemoteAccess, url, auth=auth)
        
        repos_root = ra.get_repos_root()
        branch = url[len(repos_root):]
        
        repo.uuid = ra.get_uuid()
        
        log_iter = ra.iter_log(paths=None, start=end_rev, end=1,
            strict_node_history=False, discover_changed_paths=True)
        
        # TODO: use "get_location_segments" instead
        log = list()
        while True:
            stderr.write("revision ")
            stderr.flush()
            try:
                (paths, rev, props, _) = next(log_iter)
            except StopIteration:
                print("(stopped)", file=stderr)
                break
            
            try:
                (_, src, _, _) = paths[branch]
            except LookupError:
                new = None
                print(rev, file=stderr)
            else:
                new = branch
                branch = src
                print("{}: beginning of {}".format(rev, new), file=stderr)
                
                if branch is not None:
                    prefix = branch + "/"
                    if not any(path.startswith(prefix)
                    for path in paths.keys()):
                        if log and log[-1].new_branch is None:
                            log[-1].new_branch = new
                        continue
            
            log.append(Record(
                rev=rev,
                date=props[PROP_REVISION_DATE],
                author=props[PROP_REVISION_AUTHOR],
                log = props[PROP_REVISION_LOG],
                new_branch=new,
            ))
        
        prev = 0
        trace(ra.reparent, repos_root)
        for entry in reversed(log):
            if entry.new_branch is not None:
                url = repos_root + entry.new_branch
            
            print("commit refs/heads/pyqt", file=repo.dump)
            
            date = timegm(strptime(entry.date[:19], "%Y-%m-%dT%H:%M:%S"))
            print("committer {entry.author} <{entry.author}@{repo.uuid}> "
                "{date} +0000".format(**locals()), file=repo.dump)
            
            # TODO: svn+uuid://{repo.uuid}/{root} option: more static
            log = "{}\n\ngit-svn-id: {}@{} {}\n".format(
                entry.log, url, entry.rev, repo.uuid)
            print("data", len(log), file=repo.dump)
            repo.dump.write(log)
            print(file=repo.dump)
            
            reporter = trace(ra.do_diff, entry.rev, "", url, RevEditor(repo),
                True, True, True)
            reporter.set_path("", prev, False)
            trace(reporter.finish)
            # Assume the editor calls are all completed now
            
            print(file=repo.dump)
            
            prev = entry.rev
            if entry.new_branch is not None:
                trace(ra.reparent, url)

class Editor(object):
    def __init__(self, repo):
        self.repo = repo
    close = nop
class RevEditor(Editor):
    set_target_revision = nop
    def open_root(self, base):
        return DirEditor(self.repo)
    abort = Tracer("abort")

class NodeEditor(Editor):
    change_prop = nop
class DirEditor(NodeEditor):
    @traced
    def add_directory(self, path):
        return self
    @traced
    def open_directory(self, path, base):
        return self
    @traced
    def add_file(self, path):
        return FileEditor(path, bytes(), self.repo)
    @traced
    def open_file(self, path, base):
        return FileEditor(path, self.repo.files[path], self.repo)
    @traced
    def delete_entry(self, path, rev):
        print("D", path, file=self.repo.dump)

class FileEditor(NodeEditor):
    def __init__(self, path, sbuf, *args, **kw):
        NodeEditor.__init__(self, *args, **kw)
        self.path = path
        self.sbuf = sbuf
    
    def apply_textdelta(self, base_sum):
        return DeltaWindowHandler(self)

class DeltaWindowHandler(object):
    def __init__(self, editor):
        self.editor = editor
        self.target_chunks = list()
        self.target_len = 0
    
    #~ @partial(traced, abbrev={1})
    def __call__(self, chunk):
        if chunk is None:
            self.editor.repo.dump.seek(0, SEEK_END)
            
            print("M 644 inline", self.editor.path,
                file=self.editor.repo.dump)
            print("data", self.target_len, file=self.editor.repo.dump)
            
            self.editor.repo.files[self.editor.path] = FileArray(
                self.editor.repo.dump, self.editor.repo.dump.tell(),
                self.target_len)
            for chunk in self.target_chunks:
                self.editor.repo.dump.write(chunk)
            
            print(file=self.editor.repo.dump)
        
        else:
            chunk = apply_txdelta_window(self.editor.sbuf, chunk)
            self.target_chunks.append(chunk)
            self.target_len += len(chunk)

class FileArray(object):
    def __init__(self, file, pos, len):
        self.file = file
        self.pos = pos
        self.len = len
    def __getitem__(self, slice):
        return FileArray(self.file,
            self.pos + slice.start, slice.stop - slice.start)
    #~ @partial(traced, abbrev={1, "return"})
    def __radd__(self, str):
        self.file.seek(self.pos)
        return str + self.file.read(self.len)
    def __repr__(self):
        return "{}({}, {}, {})".format(type(self).__name__,
            self.file, self.pos, self.len)

class Record(object):
    def __init__(self, *args, **kw):
        self.__dict__.update(*args, **kw)

if __name__ == "__main__":
    main(*argv)
