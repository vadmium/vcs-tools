#! /usr/bin/env python3

"""Converts from a remote Subversion repository to Git's "fast-import" format

The program is written to:

* use Subversion's remote access protocol
* minimise traffic from the Subversion server by
    * skipping revisions that do not affect the branch
    * skipping paths that are outside the branch
    * requesting deltas rather than full copies of files where practical
    * requesting exclusion of deltas for ignored files
* follow branch copies
* produce identical commits to "git-svn"
* be run incrementally

It does not:

* handle or correlate multiple trunks, branches, or tags
* take account of any kind of Subversion merge tracking
* handle symbolic links, although it does handle executable files
* do anything with special Subversion file or revision properties
"""

from subvertpy.ra import (RemoteAccess, Auth, get_username_provider)
from subvertpy.delta import apply_txdelta_window
from subvertpy.properties import (
    PROP_REVISION_DATE,
    PROP_REVISION_AUTHOR,
    PROP_REVISION_LOG,
    PROP_EXECUTABLE,
)
from sys import stderr, argv, exc_info
from subvertpy.properties import time_from_cstring
from io import SEEK_END
from subvertpy import SubversionException
from subprocess import Popen
import subprocess
import argparse
from funcparams import splitdoc
from errno import EPIPE
from contextlib import contextmanager
import subvertpy.ra

INVALID_REVNUM = -1

def main():
    (summary, _) = splitdoc(__doc__)
    parser = argparse.ArgumentParser(description=summary)
    
    parser.add_argument("url", help="subversion URL")
    parser.add_argument("--file", metavar="FILENAME",
        help="fast import file")
    parser.add_argument("importer", nargs="*",
        help="command which is piped the fast import stream")
    parser.add_argument("--git-ref", required=True, metavar="REF",
        help='should include everything that follows the "refs/" prefix')
    parser.add_argument("-r", "--revision", metavar="BASE:END",
        default="0:HEAD", help="""subversion revisions to look up (default:
        0:HEAD). If the range does not begin at zero, the existing Git branch
        is assumed to match.""")
    parser.add_argument("-A", "--authors-file", metavar="FILENAME", help=
        'file mapping Subversion user names to Git authors, like "git-svn"')
    parser.add_argument("--rewrite-root", metavar="URL",
        help="subversion URL to store in the metadata")
    parser.add_argument("--ignore", action="append", default=list(),
        metavar="PATH", help="add a path to be excluded from export")
    parser.add_argument("-q", "--quiet", action="store_true",
        help="suppress progress messages")
    
    args = parser.parse_args()
    
    (base_rev, end_rev) = args.revision.split(":")
    base_rev = parse_svn_rev(base_rev)
    end_rev = parse_svn_rev(end_rev)
    if (base_rev == INVALID_REVNUM or
    end_rev != INVALID_REVNUM and end_rev < base_rev):
        (base_rev, end_rev) = (end_rev, base_rev)
    
    if args.authors_file is not None:
        author_map = dict()
        with open(authors, "rt") as file:
            for line in file:
                if line.endswith("\n"):
                    line = line[:-1]
                (svn, git) = line.split(" = ", 1)
                author_map[svn] = git
    else:
        author_map = None
    
    try:
        Repo(args.url, args.git_ref, file=args.file, importer=args.importer,
            base_rev=base_rev, end_rev=end_rev,
            author_map=author_map,
            root=args.rewrite_root,
            ignore=args.ignore,
            quiet=args.quiet,
        )
    except SubversionException as err:
        (msg, _) = err.args
        raise SystemExit(msg)

class Repo(object):
    def __init__(self, url, git_ref, file=None, importer=(),
        base_rev=0, end_rev=INVALID_REVNUM,
        author_map=None,
        root=None,
        ignore=(),
        quiet=False,
    ):
        self.quiet = quiet
        if self.quiet:
            progress = dummycontext
        else:
            progress = progresscontext
        
        if importer:
            self.export = FastExportPipe(importer)
        else:
            self.export = FastExportFile(file)
        with self.export:
            # Auth stuff avoids the following error for diffs on local
            # (file://) URLs: "No provider registered for 'svn.username'
            # credentials"
            auth = Auth((get_username_provider(),))
            
            with progress("connecting to ", url):
                ra = RemoteAccess(url, auth=auth)
            
            repos_root = ra.get_repos_root()
            if root is None:
                root = repos_root
            
            self.uuid = ra.get_uuid()
            
            if end_rev == base_rev:
                # RemoteAccess.get_location_segments() does not support an
                # empty range, so handle this as a special case. Also, HEAD:
                # HEAD would be interpreted as the entire history.
                return
            
            self.locations = list()
            with progress("location history:"):
                ra.get_location_segments("", end_rev, end_rev, base_rev + 1,
                    self.on_location)
            
            # Not using RemoteAccess.get_file_revs() because it does not work
            # on directories
            
            # TODO: Use RemoteAccess.replay_range() for initial location
            # segment and trailing parts of subsequent segments. Would
            # require remembering all versions of files received.
            
            prev_rev = None
            for (self.rev, end, path) in reversed(self.locations):
                if path:
                    new_url = "{}/{}".format(repos_root, path)
                else:
                    new_url = repos_root
                path = "/" + path
                while self.rev < end:
                    with progress(path):
                        if url != new_url:
                            ra.reparent(new_url)
                            url = new_url
                        
                        if not self.quiet:
                            stderr.write("@")
                            stderr.flush()
                        next = self.rev + 1
                        self.rev = None
                        ra.get_log(self.on_revision, paths=None,
                            start=next, end=end, limit=1,
                            # TODO: Changed paths only needed for the first
                            # revision in each segment
                            discover_changed_paths=True)
                        if self.rev is None:
                            if not self.quiet:
                                stderr.write("(none)")
                            break
                        if not self.quiet:
                            stderr.write(format(self.rev))
                            stderr.flush()
                        
                        # Do not generate a Git commit from a simple
                        # unmodified branch copy
                        prefix = path.rstrip("/") + "/"
                        if not any(path.startswith(prefix) and path != prefix
                        for path in self.paths.keys()):
                            default = (None, None, None)
                            (_, src, _) = self.paths.get(path, default)
                            if src is not None:
                                continue
                        
                        if prev_rev is not None and prev_url is not None:
                            # This is not the first exported revision, and
                            # the previous one was at a different branch
                            # location. Will have to diff the previous
                            # location against the current location. Have to
                            # switch root because the diff reporter does not
                            # accept link_path() on the top-level directory.
                            ra.reparent(prev_url)
                            url = prev_url
                        
                        if not self.quiet:
                            stderr.write(":")
                            stderr.flush()
                        editor = RevEditor(self.export, self.quiet)
                        
                        # Diff editor does not convey deletions when starting
                        # from scratch
                        if prev_rev is None:
                            dir = DirEditor(editor)
                            for (file, (action, _, _)) in self.paths.items():
                                if (not file.startswith(prefix) or
                                action not in "DR"):
                                    continue
                                file = file[len(prefix):]
                                for p in ignore:
                                    if (file == p or
                                    file.startswith((p + "/").lstrip("/"))):
                                        break
                                else:
                                    dir.delete_entry(file)
                        
                        reporter = ra.do_diff(self.rev, "", new_url, editor,
                            True, True, True)
                        if prev_rev is None:
                            reporter.set_path("", self.rev, True)
                        else:
                            reporter.set_path("", prev_rev, False)
                        
                        for p in ignore:
                            reporter.set_path(p, INVALID_REVNUM, True, None,
                                subvertpy.ra.DEPTH_EXCLUDE)
                        
                        reporter.finish()
                        # Assume the editor calls are all completed now
                        
                        line = "commit refs/{}\n".format(git_ref)
                        self.export.file.write(line.encode("utf-8"))
                        
                        date = time_from_cstring(self.date) // 10**6
                        
                        if author_map is None:
                            author = ("{0.author} <{0.author}@{0.uuid}>".
                                format(self))
                        else:
                            author = author_map[self.author]
                        
                        line = "committer {} {} +0000\n".format(author, date)
                        self.export.file.write(line.encode("utf-8"))
                        
                        log = "{}\n\ngit-svn-id: {}{}@{} {}\n".format(
                            self.log, root, path.rstrip("/"), self.rev,
                            self.uuid)
                        log = log.encode("utf-8")
                        line = "data {}\n".format(len(log))
                        self.export.file.write(line.encode("ascii"))
                        self.export.file.writelines((log, b"\n"))
                        
                        if (prev_rev is None and
                        self.rev > 1 and not log_new_path(self.paths, path)):
                            line = "from {}\n".format(git_ref)
                            self.export.file.write(line.encode("utf-8"))
                        
                        for args in editor.edits:
                            line = " ".join(args).encode("utf-8")
                            self.export.file.writelines((line, b"\n"))
                        self.export.file.write(b"\n")
                        
                        prev_rev = self.rev
                        
                        # Last exported location is current location
                        prev_url = None
                
                # Save URL of last location that was exported
                if prev_rev is not None and prev_url is None:
                    prev_url = new_url
    
    def on_location(self, start, end, path):
        if path is None:
            return
        if not self.quiet:
            stderr.write("\n  /{}:{}-{}".format(path, start, end))
            stderr.flush()
        self.locations.append((start - 1, end, path))
    
    def on_revision(self, paths, rev, props, children=False):
        self.paths = paths
        self.rev = rev
        self.date = props[PROP_REVISION_DATE]
        self.author = props.get(PROP_REVISION_AUTHOR, "(no author)")
        self.log = props[PROP_REVISION_LOG]

class FastExport(object):
    def __init__(self, *pos, **kw):
        try:
            self.files = dict()
            self.open(*pos, **kw)
        except:
            self.__exit__(*exc_info())
            raise
    def open(self):
        pass
    def __enter__(self):
        return self
    
    def blob(self, path, buf):
        blob = self.blob_header(path, buf)
        self.file.writelines((buf, b"\n"))
        return blob
    
    def blob_header(self, path, buf):
        (mark, _) = self.files.get(path, (None, None))
        if mark is None:
            mark = ":{}".format(1 + len(self.files))
            self.files[path] = (mark,)
        
        self.file.write(b"blob\n")
        self.file.write("mark {}\n".format(mark).encode("ascii"))
        self.file.write("data {}\n".format(len(buf)).encode("ascii"))
        return mark
    
    def __setitem__(self, path, value):
        self.files[path] = value
    def __getitem__(self, path):
        return self.files[path]

class FastExportFile(FastExport):
    def __init__(self, file):
        self.filedata = dict()
        self.file = open(file, "w+b")
        FastExport.__init__(self)
    def open(self):
        self.file.tell()  # Make sure it is seekable
    def __exit__(self, *exc):
        self.file.close()
    
    def blob(self, path, buf):
        self.file.seek(0, SEEK_END)
        blob = self.blob_header(path, buf)
        filedata = FileArray(self.file, self.file.tell(), len(buf))
        self.filedata[blob] = filedata
        self.file.writelines((buf, b"\n"))
        return blob
    
    def cat_blob(self, blob):
        return self.filedata[blob]

class FastExportPipe(FastExport):
    def __init__(self, importer):
        self.proc = Popen(importer,
            stdin=subprocess.PIPE, stdout=subprocess.PIPE, bufsize=-1)
        FastExport.__init__(self)
    def open(self):
        self.file = self.proc.stdin
        self.file.write(b"feature done\n")
        self.file.write(b"feature cat-blob\n")
    
    def __exit__(self, type, value, traceback):
        try:
            if not value:
                self.file.write(b"done\n")
        except BaseException as err:
            value = err
        finally:
            self.proc.stdout.close()
            
            try:
                self.proc.stdin.close()
            except EnvironmentError as err:
                if err.errno != EPIPE:
                    raise
                # Underlying file descriptor seems to get closed anyway,
                # despite the broken pipe exception
                
                returncode = self.proc.wait()
                if not value and not returncode:
                    raise
            else:
                returncode = self.proc.wait()
            if (not value or isinstance(value, EnvironmentError)
            and value.errno == EPIPE) and returncode:
                raise SystemExit(returncode)
    
    def cat_blob(self, blob):
        self.file.write("cat-blob {}\n".format(blob).encode("ascii"))
        self.file.flush()
        size = int(self.proc.stdout.readline().split(b" ", 3)[2])
        data = self.proc.stdout.read(size)
        self.proc.stdout.readline()
        return data

class Editor(object):
    def close(self):
        pass
class RevEditor(Editor):
    def __init__(self, export, quiet):
        self.export = export
        self.quiet = quiet
        self.edits = list()
    def set_target_revision(self, rev):
        pass
    def open_root(self, base):
        return DirEditor(self)
    def abort(self):
        pass

class NodeEditor(Editor):
    def __init__(self, rev):
        self.rev = rev
    def change_prop(self, name, value):
        pass
class DirEditor(NodeEditor):
    def add_directory(self, path):
        if not self.rev.quiet:
            stderr.writelines(("\n  A ", path, "/"))
            stderr.flush()
        return self
    def open_directory(self, path, base):
        if not self.rev.quiet:
            stderr.writelines(("\n  M ", path, "/"))
            stderr.flush()
        return self
    def add_file(self, path):
        if not self.rev.quiet:
            stderr.writelines(("\n  A ", path))
            stderr.flush()
        return FileEditor(path, self.rev)
    def open_file(self, path, base):
        if not self.rev.quiet:
            stderr.writelines(("\n  M ", path))
            stderr.flush()
        return FileEditor(path, self.rev, original=self.rev.export[path])
    def delete_entry(self, path, rev=None):
        if not self.rev.quiet:
            stderr.writelines(("\n  D ", path))
            stderr.flush()
        self.rev.edits.append(("D", path))

class FileEditor(NodeEditor):
    def __init__(self, path, rev, original=(None, "644")):
        NodeEditor.__init__(self, rev)
        self.path = path
        (self.blob, self.mode) = original
    
    def change_prop(self, name, value):
        if name == PROP_EXECUTABLE:
            if value:
                self.mode = "755"
            else:
                self.mode = "644"
    
    def apply_textdelta(self, base_sum):
        return DeltaWindowHandler(self)
    
    def close(self):
        self.rev.export[self.path] = (self.blob, self.mode)
        self.rev.edits.append(("M", self.mode, self.blob, self.path))

class DeltaWindowHandler(object):
    def __init__(self, file):
        self.file = file
        if self.file.blob:
            self.sbuf = self.file.rev.export.cat_blob(self.file.blob)
        else:
            self.sbuf = bytes()
        self.target_buf = bytearray()
    
    def __call__(self, chunk):
        if chunk is None:
            self.file.blob = self.file.rev.export.blob(self.file.path,
                self.target_buf)
        else:
            chunk = apply_txdelta_window(self.sbuf, chunk)
            self.target_buf.extend(chunk)

def parse_svn_rev(rev):
    if rev.upper() == "HEAD":
        return INVALID_REVNUM
    return int(rev)

def log_new_path(changes, path):
    """See if a path has no prior history"""
    
    parent = len(path.rstrip("/"))
    while parent >= 0:
        change = changes.get(path[:parent] or "/")
        if change:
            (action, src, _) = change
            if src is not None:  # Copy with history
                return False
            if action in "AR":  # Add without history
                return True
        parent = path.rfind("/", 0, parent)
    else:  # Branch not copied
        return False

class FileArray(object):
    def __init__(self, file, pos, len):
        self.file = file
        self.pos = pos
        self.len = len
    
    def __getitem__(self, slice):
        return FileArray(self.file,
            self.pos + slice.start, slice.stop - slice.start)
    
    def __iter__(self):
        self.file.seek(self.pos)
        return iter(self.file.read(self.len))
    
    def __repr__(self):
        return "{}({}, {}, {})".format(type(self).__name__,
            self.file, self.pos, self.len)

@contextmanager
def progresscontext(*args):
    stderr.writelines(args)
    stderr.flush()
    try:
        yield
    finally:
        print(file=stderr)

@contextmanager
def dummycontext(*pos, **kw):
    yield

if __name__ == "__main__":
    main()
