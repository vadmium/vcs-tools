#! /usr/bin/env python2

"""Converter from Subversion to Git's "fast-import" format

The program is written to

* use Subversion's remote access protocol
* minimise traffic from the Subversion server by
    * skipping revisions that do not affect the branch
    * skipping paths that are outside the branch
    * requesting deltas rather than full copies of files where practical
* follow branch copies
* produce identical commits to "git-svn"
* be run incrementally

It does not

* handle or correlate multiple trunks, branches, or tags
* take account of any kind of Subversion merge tracking
* handle special kinds of files (symbolic links, executables)
* do anything with special Subversion file or revision properties
"""

from __future__ import print_function

from subvertpy.ra import (RemoteAccess, Auth, get_username_provider)
from subvertpy.delta import apply_txdelta_window
from subvertpy.properties import (
    PROP_REVISION_DATE,
    PROP_REVISION_AUTHOR,
    PROP_REVISION_LOG,
)
from sys import (stderr, argv)
from functools import partial
from time import strptime
from calendar import timegm
from io import SEEK_END
from shorthand import fields
from shorthand import nop
from calltrace import tracer
from subvertpy import SubversionException
import argparse
from funcparams import splitdoc

INVALID_REVNUM = -1

def main(url, dump, git_ref,
revision="0:HEAD", authors=None, root=None, quiet=False):
    """Transform Subversion revisions to Git's "fast-import" format
    
    url  Subversion URL
    dump  Fast import file
    git_ref  Should include everything that follows the "refs/" prefix
    revision  Subversion revisions to look up; default: 0:HEAD. If the range
        does not begin at zero, the existing Git branch is assumed to match.
    authors  File mapping Subversion user names to Git authors, like "git-
        svn"
    root  Subversion URL to store in the metadata
    quiet  Suppress progress messages
    """
    
    (base_rev, end_rev) = revision.split(":")
    base_rev = parse_svn_rev(base_rev)
    end_rev = parse_svn_rev(end_rev)
    if (base_rev == INVALID_REVNUM or
    end_rev != INVALID_REVNUM and end_rev < base_rev):
        (base_rev, end_rev) = (end_rev, base_rev)
    
    if authors is not None:
        author_map = dict()
        with open(authors, "rt") as file:
            for line in file:
                if line.endswith("\n"):
                    line = line[:-1]
                (svn, git) = line.split(" = ", 1)
                author_map[svn] = git
    else:
        author_map = None
    
    Repo(url, dump, git_ref, base_rev, end_rev, author_map, root, quiet)

class Repo(object):
    def __init__(self, url, dump, git_ref, base_rev, end_rev, author_map,
    root, quiet):
        self.files = dict()
        self.quiet = quiet
        
        with open(dump, "w+b") as self.dump:
            self.dump.tell()  # Make sure it is seekable
            
            # Auth stuff avoids the following error for diffs on local
            # (file://) URLs: "No provider registered for 'svn.username'
            # credentials"
            auth = Auth((get_username_provider(),))
            
            if not self.quiet:
                stderr.writelines(("connecting to ", url))
                stderr.flush()
            ra = RemoteAccess(url, auth=auth)
            if not self.quiet:
                print(file=stderr)
            
            repos_root = ra.get_repos_root()
            branch = url[len(repos_root):]
            if root is None:
                root = repos_root
            
            self.uuid = ra.get_uuid()
            
            # If the log's starting revision is INVALID_REVNUM, Google Code
            # seems to look up the path in the log's ending revision, which
            # fails if it wasn't created then.
            if end_rev == INVALID_REVNUM:
                if not self.quiet:
                    stderr.write("HEAD: ")
                    stderr.flush()
                end_rev = ra.get_latest_revnum()
                if not self.quiet:
                    print(end_rev, file=stderr)
            
            if end_rev == base_rev:
                # Degenerate case because no revisions are actually in the
                # range, but the log call would do a forwards log from
                # revision N to N + 1.
                return
            
            log_iter = ra.iter_log(paths=None,
                start=end_rev, end=base_rev + 1,
                strict_node_history=False, discover_changed_paths=True)
            
            # TODO: use "get_location_segments" instead
            log = list()
            while True:
                if not self.quiet:
                    stderr.write("revision ")
                    stderr.flush()
                try:
                    (paths, rev, props, _) = next(log_iter)
                except SubversionException as err:
                    (msg, _) = err.args
                    if not self.quiet:
                        print(file=stderr)
                    raise SystemExit(msg)
                except StopIteration:
                    if not self.quiet:
                        print("(stopped)", file=stderr)
                    break
                
                parent = len(branch)
                # If the branch location changed, set "new" to the current
                # branch location, and "src" to (a parent of) the previous
                # location. If the location did not change, "new" is set to
                # None.
                while True:
                    # At the root directory, this searches for the empty
                    # string "" rather than "/". This should not matter
                    # because the root directory cannot be moved from
                    # anywhere.
                    path = paths.get(branch[:parent])
                    if path:
                        (action, src, _, _) = path
                        if src is not None or action in "AR":
                            new = branch
                            break
                    
                    parent = branch.rfind("/", 0, parent)
                    if parent < 0:
                        new = None
                        break
                
                if new is None:
                    if not self.quiet:
                        print(rev, file=stderr)
                elif src is None:
                    if not self.quiet:
                        print("{}: beginning of {}".format(rev, new),
                            file=stderr)
                else:
                    branch = src + branch[parent:]
                    if not self.quiet:
                        print("{}: copied from {}".format(rev, branch),
                            file=stderr)
                    
                    prefix = new + "/"
                    if not any(path.startswith(prefix)
                    for path in paths.keys()):
                        # This revision is a simple branch copy without any
                        # file changes. Do not generate a Git commit from it.
                        if log and log[-1]["new_branch"] is None:
                            log[-1]["new_branch"] = new
                        continue
                
                log.append(dict(
                    rev=rev,
                    date=props[PROP_REVISION_DATE],
                    author=props.get(PROP_REVISION_AUTHOR, "(no author)"),
                    log = props[PROP_REVISION_LOG],
                    new_branch=new,
                ))
                
                if new is not None and src is None:
                    break
            # Make sure the underlying log call has completed
            for _ in log_iter:
                pass
            
            if log and new is None and branch != "":
                log[-1]["new_branch"] = branch
            prev = dict(rev=0, new_branch="")
            url = repos_root
            
            for entry in reversed(log):
                if prev["new_branch"] is not None:
                    if not self.quiet:
                        path = url[len(repos_root):]
                        if not path:
                            path = "/"
                        stderr.writelines(("switching to ", path))
                        stderr.flush()
                    ra.reparent(url)
                    if not self.quiet:
                        print(file=stderr)
                
                if entry["new_branch"] is not None:
                    url = repos_root + entry["new_branch"]
                path = url[len(repos_root):]
                
                print("commit refs/{}".format(git_ref), file=self.dump)
                
                date = strptime(entry["date"][:19], "%Y-%m-%dT%H:%M:%S")
                date = timegm(date)
                
                if author_map is None:
                    author = ("{author} <{author}@{uuid}>".
                        format(author=entry["author"], uuid=self.uuid))
                else:
                    author = author_map[entry["author"]]
                
                print("committer {} {} +0000".format(author, date),
                    file=self.dump)
                
                log = "{}\n\ngit-svn-id: {}{}@{} {}\n".format(
                    entry["log"], root, path, entry["rev"], self.uuid)
                print("data", len(log), file=self.dump)
                self.dump.write(log)
                print(file=self.dump)
                
                if not prev["rev"] and base_rev:
                    print("from", git_ref, file=self.dump)
                
                if not self.quiet:
                    stderr.write("{}@{}".format(path, entry["rev"]))
                    stderr.flush()
                reporter = ra.do_diff(entry["rev"], "", url, RevEditor(self),
                    True, True, True)
                
                if not self.quiet:
                    stderr.write(":")
                    stderr.flush()
                reporter.set_path("", prev["rev"], False)
                reporter.finish()
                # Assume the editor calls are all completed now
                if not self.quiet:
                    print(file=stderr)
                
                print(file=self.dump)
                
                prev = entry

class Editor(object):
    def __init__(self, repo):
        self.repo = repo
    close = nop
class RevEditor(Editor):
    set_target_revision = nop
    def open_root(self, base):
        return DirEditor(self.repo)
    abort = tracer("abort")

class NodeEditor(Editor):
    change_prop = nop
class DirEditor(NodeEditor):
    def add_directory(self, path):
        if not self.repo.quiet:
            stderr.writelines(("\n  A ", path, "/"))
        return self
    def open_directory(self, path, base):
        if not self.repo.quiet:
            stderr.writelines(("\n  M ", path, "/"))
        return self
    def add_file(self, path):
        if not self.repo.quiet:
            stderr.writelines(("\n  A ", path))
        return FileEditor(path, bytes(), self.repo)
    def open_file(self, path, base):
        if not self.repo.quiet:
            stderr.writelines(("\n  M ", path))
        return FileEditor(path, self.repo.files[path], self.repo)
    def delete_entry(self, path, rev):
        if not self.repo.quiet:
            stderr.writelines(("\n  D ", path))
        print("D", path, file=self.repo.dump)

class FileEditor(NodeEditor):
    def __init__(self, path, sbuf, *args, **kw):
        NodeEditor.__init__(self, *args, **kw)
        self.path = path
        self.sbuf = sbuf
    
    def apply_textdelta(self, base_sum):
        return DeltaWindowHandler(self)

class DeltaWindowHandler(object):
    def __init__(self, editor):
        self.editor = editor
        self.target_chunks = list()
        self.target_len = 0
    
    #~ @partial(traced, abbrev={1})
    def __call__(self, chunk):
        if chunk is None:
            self.editor.repo.dump.seek(0, SEEK_END)
            
            print("M 644 inline", self.editor.path,
                file=self.editor.repo.dump)
            print("data", self.target_len, file=self.editor.repo.dump)
            
            self.editor.repo.files[self.editor.path] = FileArray(
                self.editor.repo.dump, self.editor.repo.dump.tell(),
                self.target_len)
            for chunk in self.target_chunks:
                self.editor.repo.dump.write(chunk)
            
            print(file=self.editor.repo.dump)
        
        else:
            chunk = apply_txdelta_window(self.editor.sbuf, chunk)
            self.target_chunks.append(chunk)
            self.target_len += len(chunk)

def parse_svn_rev(rev):
    if rev.upper() == "HEAD":
        return INVALID_REVNUM
    return int(rev)

class FileArray(object):
    def __init__(self, file, pos, len):
        self.file = file
        self.pos = pos
        self.len = len
    def __getitem__(self, slice):
        return FileArray(self.file,
            self.pos + slice.start, slice.stop - slice.start)
    #~ @partial(traced, abbrev={1, "return"})
    def __radd__(self, str):
        self.file.seek(self.pos)
        return str + self.file.read(self.len)
    def __repr__(self):
        return "{}({}, {}, {})".format(type(self).__name__,
            self.file, self.pos, self.len)

if __name__ == "__main__":
    (summary, _) = splitdoc(main.__doc__)
    parser = argparse.ArgumentParser(description=summary)
    parser.add_argument("url", help="subversion URL")
    parser.add_argument("dump", help="fast import file")
    parser.add_argument("git_ref",
        help='should include everything that follows the "refs/" prefix')
    parser.add_argument("-r", "--revision", metavar="BASE:END",
        default="0:HEAD", help="""subversion revisions to look up (default:
        0:HEAD). If the range does not begin at zero, the existing Git branch
        is assumed to match.""")
    parser.add_argument("-A", "--authors-file", metavar="FILENAME", help=
        'file mapping Subversion user names to Git authors, like "git-svn"')
    parser.add_argument("--rewrite-root", metavar="URL",
        help="subversion URL to store in the metadata")
    parser.add_argument("-q", "--quiet", action="store_true",
        help="suppress progress messages")
    args = parser.parse_args()
    main(args.url, args.dump, args.git_ref, revision=args.revision,
        authors=args.authors_file, root=args.rewrite_root, quiet=args.quiet)
