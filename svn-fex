#! /usr/bin/env python2
from __future__ import print_function

"""Converter from Subversion to Git's "fast-import" format

The program is written to

* use Subversion's remote access protocol
* minimise traffic from the Subversion server by
    * skipping revisions that do not affect the branch
    * skipping paths that are outside the branch
    * requesting deltas rather than full copies of files where practical
* follow branch copies
* produce identical commits to "git-svn"
* be run incrementally

It does not

* handle or correlate multiple trunks, branches, or tags
* take account of any kind of Subversion merge tracking
* handle special kinds of files (symbolic links, executables)
* do anything with special Subversion file or revision properties
"""

from subvertpy.ra import (RemoteAccess, Auth, get_username_provider)
from subvertpy.delta import apply_txdelta_window
from subvertpy.properties import (
    PROP_REVISION_DATE,
    PROP_REVISION_AUTHOR,
    PROP_REVISION_LOG,
)
from sys import (stderr, argv)
from functools import partial
from time import strptime
from calendar import timegm
from io import SEEK_END
from lib import Record
from lib import fields
from lib import nop
from lib.ftrace import (traced, Tracer)

INVALID_REVNUM = -1

@fields(arg_types=dict(end_rev=int, base_rev=int))
def main(dump, git_ref, url,
end_rev=INVALID_REVNUM, base_rev=0, authors=None):
    """Transform Subversion revisions to Git's "fast-import" format
    
    Usage: svn-fex <fast-import file> <ref name> <subversion URL> [options]
    
    The <ref name> argument should include everything that follows the
    "refs/" prefix.
    
    Options:
    -end_rev  Subversion revision to look up; default: HEAD
    -base_rev  Subversion revision to begin from; default: 0. If not zero,
        the existing Git branch is assumed to match.
    -authors  File mapping Subversion user names to Git authors, like "git-
        svn"
    """
    
    if authors is not None:
        author_map = dict()
        with open(authors, "rt") as file:
            for line in file:
                if line.endswith("\n"):
                    line = line[:-1]
                (svn, git) = line.split(" = ", 1)
                author_map[svn] = git
    
    repo = Record(files=dict())
    uuid_url = True
    
    with open(dump, "w+b") as repo.dump:
        # Auth stuff avoids the following error for diffs on local (file://)
        # URLs: "No provider registered for 'svn.username' credentials"
        auth = Auth((get_username_provider(),))
        
        ra = traced(RemoteAccess)(url, auth=auth)
        
        repos_root = ra.get_repos_root()
        branch = url[len(repos_root):]
        
        repo.uuid = ra.get_uuid()
        
        # If the log's starting revision is INVALID_REVNUM, Google Code seems
        # to look up the path in the log's ending revision, which fails if it
        # wasn't created then.
        if end_rev == INVALID_REVNUM:
            end_rev = traced(ra.get_latest_revnum)()
        
        log_iter = ra.iter_log(paths=None, start=end_rev, end=base_rev + 1,
            strict_node_history=False, discover_changed_paths=True)
        
        # TODO: use "get_location_segments" instead
        log = list()
        while True:
            stderr.write("revision ")
            stderr.flush()
            try:
                (paths, rev, props, _) = next(log_iter)
            except StopIteration:
                print("(stopped)", file=stderr)
                break
            
            parent = len(branch)
            while True:
                try:
                    (_, src, _, _) = paths[branch[:parent]]
                except LookupError:
                    pass
                else:
                    new = branch
                    break
                
                try:
                    parent = branch.rindex("/", 0, parent)
                except ValueError:
                    new = None
                    break
            
            if new is None:
                print(rev, file=stderr)
            elif src is None:
                print("{}: beginning of {}".format(rev, new), file=stderr)
            else:
                branch = src + branch[parent:]
                print("{rev}: copied from {branch}".format(**locals()),
                    file=stderr)
                
                prefix = new + "/"
                if not any(path.startswith(prefix)
                for path in paths.keys()):
                    # This revision is a simple branch copy without any
                    # file changes. Do not generate a Git commit from it.
                    if log and log[-1].new_branch is None:
                        log[-1].new_branch = new
                    continue
            
            log.append(Record(
                rev=rev,
                date=props[PROP_REVISION_DATE],
                author=props[PROP_REVISION_AUTHOR],
                log = props[PROP_REVISION_LOG],
                new_branch=new,
            ))
            
            if new is not None and src is None:
                break
        
        if log and new is None and branch != "":
            log[-1].new_branch = branch
        prev = Record(rev=0, new_branch="")
        url = repos_root
        
        for entry in reversed(log):
            if prev.new_branch is not None:
                traced(ra.reparent)(url)
            
            if entry.new_branch is not None:
                url = repos_root + entry.new_branch
            
            print("commit refs/{}".format(git_ref), file=repo.dump)
            
            date = timegm(strptime(entry.date[:19], "%Y-%m-%dT%H:%M:%S"))
            
            if authors is None:
                author = ("{entry.author} <{entry.author}@{repo.uuid}>".
                    format(**locals()))
            else:
                author = author_map[entry.author]
            
            print("committer {author} {date} +0000".format(**locals()),
                file=repo.dump)
            
            if uuid_url:
                log = "{}\n\ngit-svn-id: {}@{} {}\n".format(
                    entry.log, url[len(repos_root):], entry.rev, repo.uuid)
            else:
                log = "{}\n\ngit-svn-id: {}@{} {}\n".format(
                    entry.log, url, entry.rev, repo.uuid)
            print("data", len(log), file=repo.dump)
            repo.dump.write(log)
            print(file=repo.dump)
            
            if not prev.rev and base_rev:
                print("from", git_ref, file=repo.dump)
            
            reporter = traced(ra.do_diff)(entry.rev, "", url, RevEditor(repo),
                True, True, True)
            reporter.set_path("", prev.rev, False)
            traced(reporter.finish)()
            # Assume the editor calls are all completed now
            
            print(file=repo.dump)
            
            prev = entry

class Editor(object):
    def __init__(self, repo):
        self.repo = repo
    close = nop
class RevEditor(Editor):
    set_target_revision = nop
    def open_root(self, base):
        return DirEditor(self.repo)
    abort = Tracer("abort")

class NodeEditor(Editor):
    change_prop = nop
class DirEditor(NodeEditor):
    @traced
    def add_directory(self, path):
        return self
    @traced
    def open_directory(self, path, base):
        return self
    @traced
    def add_file(self, path):
        return FileEditor(path, bytes(), self.repo)
    @traced
    def open_file(self, path, base):
        return FileEditor(path, self.repo.files[path], self.repo)
    @traced
    def delete_entry(self, path, rev):
        print("D", path, file=self.repo.dump)

class FileEditor(NodeEditor):
    def __init__(self, path, sbuf, *args, **kw):
        NodeEditor.__init__(self, *args, **kw)
        self.path = path
        self.sbuf = sbuf
    
    def apply_textdelta(self, base_sum):
        return DeltaWindowHandler(self)

class DeltaWindowHandler(object):
    def __init__(self, editor):
        self.editor = editor
        self.target_chunks = list()
        self.target_len = 0
    
    #~ @partial(traced, abbrev={1})
    def __call__(self, chunk):
        if chunk is None:
            self.editor.repo.dump.seek(0, SEEK_END)
            
            print("M 644 inline", self.editor.path,
                file=self.editor.repo.dump)
            print("data", self.target_len, file=self.editor.repo.dump)
            
            self.editor.repo.files[self.editor.path] = FileArray(
                self.editor.repo.dump, self.editor.repo.dump.tell(),
                self.target_len)
            for chunk in self.target_chunks:
                self.editor.repo.dump.write(chunk)
            
            print(file=self.editor.repo.dump)
        
        else:
            chunk = apply_txdelta_window(self.editor.sbuf, chunk)
            self.target_chunks.append(chunk)
            self.target_len += len(chunk)

class FileArray(object):
    def __init__(self, file, pos, len):
        self.file = file
        self.pos = pos
        self.len = len
    def __getitem__(self, slice):
        return FileArray(self.file,
            self.pos + slice.start, slice.stop - slice.start)
    #~ @partial(traced, abbrev={1, "return"})
    def __radd__(self, str):
        self.file.seek(self.pos)
        return str + self.file.read(self.len)
    def __repr__(self):
        return "{}({}, {}, {})".format(type(self).__name__,
            self.file, self.pos, self.len)

from lib import run_main
run_main(__name__)
