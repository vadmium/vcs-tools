#! /usr/bin/env python3

"""Converts from a remote Subversion repository to Git's "fast-import" format

The program is written to:

* use Subversion's remote access protocol
* minimise traffic from the Subversion server by
    * skipping revisions that do not affect the branch
    * skipping paths that are outside the branch
    * requesting deltas rather than full copies of files where practical
    * requesting exclusion of deltas for ignored files
* follow branch copies
* produce identical commits to "git-svn", except that it
    * optionally drops commits that are simple branch copies
* be run incrementally

It does not:

* handle or correlate multiple trunks, branches, or tags
* take account of any kind of Subversion merge tracking
* handle symbolic links, although it does handle executable files
* do anything with special Subversion file or revision properties
"""

from subvertpy.ra import RemoteAccess, Auth, get_username_provider
from subvertpy.delta import apply_txdelta_window
from subvertpy.properties import (
    PROP_REVISION_DATE,
    PROP_REVISION_AUTHOR,
    PROP_REVISION_LOG,
    PROP_EXECUTABLE,
)
from sys import stderr, argv, exc_info
from subvertpy.properties import time_from_cstring
from io import SEEK_END
from subvertpy import SubversionException
from subprocess import Popen
import subprocess
import argparse
from funcparams import splitdoc
from errno import EPIPE
from contextlib import contextmanager
import subvertpy.ra
from collections import defaultdict
from bisect import bisect_right, bisect_left
from contextlib import closing
from misc import Context

INVALID_REVNUM = -1

def main():
    (summary, _) = splitdoc(__doc__)
    parser = argparse.ArgumentParser(description=summary)
    
    parser.add_argument("url", metavar="url[@rev]", help="subversion URL")
    
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("--file",
        metavar="FILENAME", help="fast import file")
    group.add_argument("importer", nargs="*", default=(),
        help="command to pipe fast import stream to")
    
    parser.add_argument("--git-ref", required=True, metavar="REFNAME",
        help="Git ref name to export to (e.g. refs/remotes/svn/trunk)")
    parser.add_argument("--rev-map", action="append", default=list(),
        metavar="BRANCH@SVN-REV:GIT-REV", help="""add a mapping from a
        Subversion path and revision to an existing Git revision""")
    parser.add_argument("-A", "--authors-file", metavar="FILENAME", help=
        'file mapping Subversion user names to Git authors, like "git-svn"')
    parser.add_argument("--rewrite-root",
        metavar="URL", help="subversion URL to store in the metadata")
    parser.add_argument("--ignore", action="append", default=list(),
        metavar="PATH", help="add a path to be excluded from export")
    parser.add_argument("--export-copies", action="store_true",
        help="export simple branch copies even when no files were modified")
    parser.add_argument("-q", "--quiet", action="store_true",
        help="suppress progress messages")
    
    args = parser.parse_args()
    
    (url, _, peg_rev) = args.url.rpartition("@")
    if url:
        peg_rev = int(peg_rev)
    else:
        url = peg_rev
        peg_rev = INVALID_REVNUM
    
    rev_map = defaultdict(dict)
    for s in args.rev_map:
        (s, gitrev) = s.rsplit(":", 1)
        (branch, svnrev) = s.rsplit("@", 1)
        svnrev = int(svnrev)
        rev_map[branch][svnrev] = gitrev
    
    if args.authors_file is not None:
        author_map = dict()
        with open(args.authors_file, "rt") as file:
            for line in file:
                if line.endswith("\n"):
                    line = line[:-1]
                (svn, git) = line.split(" = ", 1)
                author_map[svn] = git
    else:
        author_map = None
    
    try:
        Repo(url, args.git_ref, file=args.file, importer=args.importer,
            peg_rev=peg_rev,
            rev_map=rev_map,
            author_map=author_map,
            root=args.rewrite_root,
            ignore=args.ignore,
            export_copies=args.export_copies,
            quiet=args.quiet,
        )
    except SubversionException as err:
        (msg, _) = err.args
        raise SystemExit(msg)

class Repo(object):
    def __init__(self, url, git_ref, file=None, importer=(),
        peg_rev=INVALID_REVNUM,
        rev_map={},
        author_map=None,
        root=None,
        ignore=(),
        export_copies=False,
        quiet=False,
    ):
        self.export_copies = export_copies
        
        known_branches = dict()
        for (branch, revs) in rev_map.items():
            starts = list()
            runs = list()
            known_branches[branch] = (starts, runs)
            start = None
            run = ()
            for (svnrev, gitrev) in sorted(revs.items()):
                if svnrev - len(run) != start:
                    start = svnrev
                    starts.append(start)
                    run = list()
                    runs.append(run)
                run.append(gitrev)
        
        self.quiet = quiet
        if self.quiet:
            self.progress = dummycontext
        else:
            self.progress = progresscontext
        
        if importer:
            self.export = FastExportPipe(importer)
        else:
            self.export = FastExportFile(file)
        with self.export:
            # Auth stuff avoids the following error for diffs on local
            # (file:) URLs: "No provider registered for 'svn.username'
            # credentials"
            auth = Auth((get_username_provider(),))
            
            with self.progress("connecting to ", url):
                self.ra = RemoteAccess(url, auth=auth)
                self.url = url
            
            self.repos_root = self.ra.get_repos_root()
            if root is None:
                root = self.repos_root
            
            self.uuid = self.ra.get_uuid()
            segments = PendingSegments(self, peg_rev, known_branches)
            
            # Not using RemoteAccess.get_file_revs() because it does not work
            # on directories
            
            # TODO: Use RemoteAccess.replay_range() for initial location
            # segment and trailing parts of subsequent segments. Would
            # require remembering all versions of files received.
            
            prev_rev = None  # Last exported Subversion revision
            for (base, end, path) in segments:
                path = "/" + path
                prefix = path.rstrip("/") + "/"
                url = (self.repos_root + path).rstrip("/")
                with iter_revs(self, path, base, end) as revs:
                    for (rev, date, author, log, paths) in revs:
                        if prev_rev is not None and prev_url is not None:
                            # This is not the first exported revision, and
                            # the previous one was at a different branch
                            # location. Will have to diff the previous
                            # location against the current location. Have to
                            # switch root because the diff reporter does not
                            # accept link_path() on the top-level directory.
                            self.ra.reparent(prev_url)
                            self.url = prev_url
                        
                        if not self.quiet:
                            stderr.write(":")
                            stderr.flush()
                        editor = RevEditor(self.export, self.quiet)
                        
                        # Diff editor does not convey deletions when starting
                        # from scratch
                        if prev_rev is None:
                            dir = DirEditor(editor)
                            for (file, (action, _, _)) in paths.items():
                                if (not file.startswith(prefix) or
                                action not in "DR"):
                                    continue
                                file = file[len(prefix):]
                                for p in ignore:
                                    if (file == p or
                                    file.startswith((p + "/").lstrip("/"))):
                                        break
                                else:
                                    dir.delete_entry(file)
                        
                        reporter = self.ra.do_diff(rev, "", url, editor,
                            True, True, True)
                        if prev_rev is None:
                            reporter.set_path("", rev, True)
                        else:
                            reporter.set_path("", prev_rev, False)
                        
                        for p in ignore:
                            reporter.set_path(p, INVALID_REVNUM, True, None,
                                subvertpy.ra.DEPTH_EXCLUDE)
                        
                        reporter.finish()
                        # Assume the editor calls are all completed now
                        
                        line = "commit {}\n".format(git_ref)
                        self.export.file.write(line.encode("utf-8"))
                        
                        date = time_from_cstring(date) // 10**6
                        
                        if author_map is None:
                            author = "{author} <{author}@{uuid}>".format(
                                author=author, uuid=self.uuid)
                        else:
                            author = author_map[author]
                        
                        line = "committer {} {} +0000\n".format(author, date)
                        self.export.file.write(line.encode("utf-8"))
                        
                        log = "{}\n\ngit-svn-id: {}{}@{} {}\n".format(
                            log, root, path.rstrip("/"), rev, self.uuid)
                        log = log.encode("utf-8")
                        line = "data {}\n".format(len(log))
                        self.export.file.write(line.encode("ascii"))
                        self.export.file.writelines((log, b"\n"))
                        
                        if prev_rev is None:
                            (prev_path, prev_rev) = log_get_parent(
                                rev, paths, path)
                            if prev_rev:
                                branch = path.lstrip("/")
                                (starts, runs) = known_branches[branch]
                                i = bisect_left(starts, prev_rev) - 1
                                git_rev = runs[i][prev_rev - starts[i]]
                                line = "from {}\n".format(git_rev)
                                self.export.file.write(line.encode("utf-8"))
                        
                        for line in editor.edits:
                            line = line.encode("utf-8")
                            self.export.file.writelines((line, b"\n"))
                        self.export.file.write(b"\n")
                        
                        prev_rev = rev
                        
                        # Last exported location is current location
                        prev_url = None
                
                # Save URL of last location that was exported
                if prev_rev is not None and prev_url is None:
                    prev_url = url

class PendingSegments:
    def __init__(self, exporter, rev, known_branches):
        self.exporter = exporter
        self.known_branches = known_branches
        
        # List of (base, end, path), from youngest to oldest segment.
        # All revisions in each segment need importing.
        self.segments = list()
        
        with self.exporter.progress("location history:"):
            try:
                self.exporter.ra.get_location_segments("", rev,
                    rev, INVALID_REVNUM, self.on_segment)
            except StopIteration:
                pass
    
    def on_segment(self, start, end, path):
        if path is None:
            return
        if not self.exporter.quiet:
            stderr.write("\n  /{}:{}-{}".format(path, start, end))
            stderr.flush()
        
        (kstarts, runs) = self.known_branches.get(path, ((), ()))
        i = bisect_right(kstarts, end)
        # Only kstarts[:i] are all <= end. If it exists, kstart[i] > end.
        
        if i:
            # Already imported segment at index i - 1 might overlap
            
            # First revision to import
            kend = kstarts[i - 1] + len(runs[i - 1])
            if kend > start:
                # Not all revisions in segment are younger
                
                if kend <= end:
                    # Part of segment is younger, thus still needs importing
                    self.segments.append((kend - 1, end, path))
                # else: No part of segment is younger
                
                raise StopIteration()
            # else: Entire segment is younger: import all revisions
        # else: Nothing imported yet
        
        self.segments.append((start - 1, end, path))
    
    def __iter__(self):
        return reversed(self.segments)

def iter_revs(*pos, **kw):
    return closing(iter(ExportRevs(*pos, **kw)))

class ExportRevs:
    def __init__(self, exporter, path, base, end):
        self.exporter = exporter
        self.path = path
        self.prefix = self.path.rstrip("/") + "/"
        self.url = (self.exporter.repos_root + self.path).rstrip("/")
        self.rev = max(base, 0)
        self.end = end
    
    def __iter__(self):
        """
        Always ensures the RA object is parented at the branch location of
        interest before yielding."""
        
        while self.rev < self.end:
            with self.exporter.progress(self.path):
                if self.exporter.url != self.url:
                    self.exporter.ra.reparent(self.url)
                    self.exporter.url = self.url
                
                if not self.exporter.quiet:
                    stderr.write("@")
                    stderr.flush()
                next = self.rev + 1
                self.rev = None
                self.exporter.ra.get_log(self.on_revision,
                    strict_node_history=False, paths=None,
                    start=next, end=self.end, limit=1,
                    
                    # TODO: Changed paths only needed for the first revision
                    # in each segment
                    discover_changed_paths=True,
                )
                
                if self.rev is None:
                    if not self.exporter.quiet:
                        stderr.write("(none)")
                    break
                if not self.exporter.quiet:
                    stderr.write(format(self.rev))
                    stderr.flush()
                
                if (not self.exporter.export_copies and
                not any(path.startswith(self.prefix) and
                path != self.prefix for path in self.paths.keys())):
                    default = (None, None, None)
                    (_, src, _) = self.paths.get(self.path, default)
                    if src is not None:
                        continue
                
                yield (self.rev, self.date, self.author, self.log,
                    self.paths)
    
    def on_revision(self, paths, rev, props, children=False):
        self.paths = paths
        self.rev = rev
        self.date = props[PROP_REVISION_DATE]
        self.author = props.get(PROP_REVISION_AUTHOR, "(no author)")
        self.log = props[PROP_REVISION_LOG]

class FastExport(Context):
    def __init__(self, *pos, **kw):
        try:
            self.files = dict()
            self.open(*pos, **kw)
        except:
            self.__exit__(*exc_info())
            raise
    def open(self):
        pass
    
    def blob(self, path, buf):
        blob = self.blob_header(path, buf)
        self.file.writelines((buf, b"\n"))
        return blob
    
    def blob_header(self, path, buf):
        (mark, _) = self.files.get(path, (None, None))
        if mark is None:
            mark = ":{}".format(1 + len(self.files))
            self.files[path] = (mark,)
        
        self.file.write(b"blob\n")
        self.file.write("mark {}\n".format(mark).encode("ascii"))
        self.file.write("data {}\n".format(len(buf)).encode("ascii"))
        return mark
    
    def __setitem__(self, path, value):
        self.files[path] = value
    def __getitem__(self, path):
        return self.files[path]

class FastExportFile(FastExport):
    def __init__(self, file):
        self.filedata = dict()
        self.file = open(file, "w+b")
        FastExport.__init__(self)
    def close(self):
        return self.file.close()
    
    def blob(self, path, buf):
        self.file.seek(0, SEEK_END)
        blob = self.blob_header(path, buf)
        filedata = FileArray(self.file, self.file.tell(), len(buf))
        self.filedata[blob] = filedata
        self.file.writelines((buf, b"\n"))
        return blob
    
    def cat_blob(self, blob):
        return self.filedata[blob]

class FastExportPipe(FastExport):
    def __init__(self, importer):
        self.proc = Popen(importer,
            stdin=subprocess.PIPE, stdout=subprocess.PIPE, bufsize=-1)
        FastExport.__init__(self)
    def open(self):
        self.file = self.proc.stdin
        self.file.write(b"feature done\n")
        self.file.write(b"feature cat-blob\n")
    
    def __exit__(self, type, value, traceback):
        try:
            if not value:
                self.file.write(b"done\n")
        except BaseException as err:
            value = err
        finally:
            self.proc.stdout.close()
            
            try:
                self.proc.stdin.close()
            except EnvironmentError as err:
                if err.errno != EPIPE:
                    raise
                # Underlying file descriptor seems to get closed anyway,
                # despite the broken pipe exception
                
                returncode = self.proc.wait()
                if not value and not returncode:
                    raise
            else:
                returncode = self.proc.wait()
            if (not value or isinstance(value, EnvironmentError)
            and value.errno == EPIPE) and returncode:
                raise SystemExit(returncode)
    
    def cat_blob(self, blob):
        self.file.write("cat-blob {}\n".format(blob).encode("ascii"))
        self.file.flush()
        size = int(self.proc.stdout.readline().split(b" ", 3)[2])
        data = self.proc.stdout.read(size)
        self.proc.stdout.readline()
        return data

class Editor(object):
    def close(self):
        pass

class RevEditor(Editor):
    def __init__(self, export, quiet):
        self.export = export
        self.quiet = quiet
        self.edits = list()
    def set_target_revision(self, rev):
        pass
    def open_root(self, base):
        return DirEditor(self)
    def abort(self):
        pass

class NodeEditor(Editor):
    def __init__(self, rev):
        self.rev = rev
    def change_prop(self, name, value):
        pass

class DirEditor(NodeEditor):
    def add_directory(self, path):
        if not self.rev.quiet:
            stderr.writelines(("\n  A ", path, "/"))
            stderr.flush()
        return self
    def open_directory(self, path, base):
        if not self.rev.quiet:
            stderr.writelines(("\n  M ", path, "/"))
            stderr.flush()
        return self
    
    def add_file(self, path):
        if not self.rev.quiet:
            stderr.writelines(("\n  A ", path))
            stderr.flush()
        return FileEditor(path, self.rev)
    
    def open_file(self, path, base):
        if not self.rev.quiet:
            stderr.writelines(("\n  M ", path))
            stderr.flush()
        return FileEditor(path, self.rev, original=self.rev.export[path])
    
    def delete_entry(self, path, rev=None):
        if not self.rev.quiet:
            stderr.writelines(("\n  D ", path))
            stderr.flush()
        self.rev.edits.append("D {}".format(path))

class FileEditor(NodeEditor):
    def __init__(self, path, rev, original=(None, "644")):
        NodeEditor.__init__(self, rev)
        self.path = path
        (self.blob, self.mode) = original
    
    def change_prop(self, name, value):
        if name == PROP_EXECUTABLE:
            if value:
                self.mode = "755"
            else:
                self.mode = "644"
    
    def apply_textdelta(self, base_sum):
        return DeltaWindowHandler(self)
    
    def close(self):
        self.rev.export[self.path] = (self.blob, self.mode)
        self.rev.edits.append("M {0.mode} {0.blob} {0.path}".format(self))

class DeltaWindowHandler(object):
    def __init__(self, file):
        self.file = file
        if self.file.blob:
            self.sbuf = self.file.rev.export.cat_blob(self.file.blob)
        else:
            self.sbuf = bytes()
        self.target_buf = bytearray()
    
    def __call__(self, chunk):
        if chunk is None:
            self.file.blob = self.file.rev.export.blob(self.file.path,
                self.target_buf)
        else:
            chunk = apply_txdelta_window(self.sbuf, chunk)
            self.target_buf.extend(chunk)

def log_get_parent(rev, changes, path):
    """Get the path and revision that the given path was based on
    
    * If the path was copied with history, return (path, rev) of where it was
        copied from
    * If the path was added without history, return ("/", 0)
    * If the path evolved normally from the previous revision, return (path,
        rev - 1)"""
    
    parent = len(path.rstrip("/"))
    while parent >= 0:
        change = changes.get(path[:parent] or "/")
        if change:
            (action, src, srcrev) = change
            if src is not None:  # Copy with history
                return (src + path[parent:], srcrev)
            if action in "AR":  # Add without history
                return ("/", 0)
        parent = path.rfind("/", 0, parent)
    else:  # Branch not copied
        return (path, rev - 1)

class FileArray(object):
    def __init__(self, file, pos, len):
        self.file = file
        self.pos = pos
        self.len = len
    
    def __getitem__(self, slice):
        return FileArray(self.file,
            self.pos + slice.start, slice.stop - slice.start)
    
    def __iter__(self):
        self.file.seek(self.pos)
        return iter(self.file.read(self.len))
    
    def __repr__(self):
        return "{}({}, {}, {})".format(type(self).__name__,
            self.file, self.pos, self.len)

@contextmanager
def progresscontext(*args):
    stderr.writelines(args)
    stderr.flush()
    try:
        yield
    finally:
        print(file=stderr)

@contextmanager
def dummycontext(*pos, **kw):
    yield

if __name__ == "__main__":
    main()
