#! /usr/bin/env python2

"""Converts from a remote Subversion repository to Git's "fast-import" format

The program is written to:

* use Subversion's remote access protocol
* minimise traffic from the Subversion server by
    * skipping revisions that do not affect the branch
    * skipping paths that are outside the branch
    * requesting deltas rather than full copies of files where practical
* follow branch copies
* produce identical commits to "git-svn"
* be run incrementally

It does not:

* handle or correlate multiple trunks, branches, or tags
* take account of any kind of Subversion merge tracking
* handle special kinds of files (symbolic links, executables)
* do anything with special Subversion file or revision properties
"""

from __future__ import print_function

from subvertpy.ra import (RemoteAccess, Auth, get_username_provider)
from subvertpy.delta import apply_txdelta_window
from subvertpy.properties import (
    PROP_REVISION_DATE,
    PROP_REVISION_AUTHOR,
    PROP_REVISION_LOG,
)
from sys import (stderr, argv)
from time import strptime
from calendar import timegm
from io import SEEK_END
from subvertpy import SubversionException
import argparse
from funcparams import splitdoc
from contextlib import contextmanager

INVALID_REVNUM = -1

def main(url, dump, git_ref,
revision="0:HEAD", authors=None, root=None, quiet=False):
    """Transform Subversion revisions to Git's "fast-import" format
    
    url  Subversion URL
    dump  Fast import file
    git_ref  Should include everything that follows the "refs/" prefix
    revision  Subversion revisions to look up; default: 0:HEAD. If the range
        does not begin at zero, the existing Git branch is assumed to match.
    authors  File mapping Subversion user names to Git authors, like "git-
        svn"
    root  Subversion URL to store in the metadata
    quiet  Suppress progress messages
    """
    
    (base_rev, end_rev) = revision.split(":")
    base_rev = parse_svn_rev(base_rev)
    end_rev = parse_svn_rev(end_rev)
    if (base_rev == INVALID_REVNUM or
    end_rev != INVALID_REVNUM and end_rev < base_rev):
        (base_rev, end_rev) = (end_rev, base_rev)
    
    if authors is not None:
        author_map = dict()
        with open(authors, "rt") as file:
            for line in file:
                if line.endswith("\n"):
                    line = line[:-1]
                (svn, git) = line.split(" = ", 1)
                author_map[svn] = git
    else:
        author_map = None
    
    try:
        Repo(url, dump, git_ref, base_rev, end_rev, author_map, root, quiet)
    except SubversionException as err:
        (msg, _) = err.args
        raise SystemExit(msg)

class Repo(object):
    def __init__(self, url, dump, git_ref, base_rev, end_rev, author_map,
    root, quiet):
        self.files = dict()
        self.quiet = quiet
        if self.quiet:
            progress = dummycontext
        else:
            progress = progresscontext
        
        with open(dump, "w+b") as self.dump:
            self.dump.tell()  # Make sure it is seekable
            
            # Auth stuff avoids the following error for diffs on local
            # (file://) URLs: "No provider registered for 'svn.username'
            # credentials"
            auth = Auth((get_username_provider(),))
            
            with progress("connecting to ", url):
                ra = RemoteAccess(url, auth=auth)
            
            repos_root = ra.get_repos_root()
            if root is None:
                root = repos_root
            
            self.uuid = ra.get_uuid()
            
            if end_rev == base_rev:
                # RemoteAccess.get_location_segments() does not support an
                # empty range, so handle this as a special case. Also, HEAD:
                # HEAD would be interpreted as the entire history.
                return
            
            self.locations = list()
            with progress("location history:"):
                ra.get_location_segments("", end_rev, end_rev, base_rev + 1,
                    self.on_location)
            
            # Not using RemoteAccess.get_file_revs() because it does not work
            # on directories
            
            # TODO: Use RemoteAccess.replay_range() for initial location
            # segment and trailing parts of subsequent segments. Would
            # require remembering all versions of files received.
            
            prev_rev = None
            for (self.rev, end, path) in reversed(self.locations):
                if path:
                    new_url = "{}/{}".format(repos_root, path)
                else:
                    new_url = repos_root
                path = "/" + path
                while self.rev < end:
                    with progress(path):
                        if url != new_url:
                            ra.reparent(new_url)
                            url = new_url
                        
                        if not self.quiet:
                            stderr.write("@")
                            stderr.flush()
                        next = self.rev + 1
                        self.rev = None
                        ra.get_log(self.on_revision, paths=None,
                            start=next, end=end, limit=1,
                            # TODO: Changed paths only needed for the first
                            # revision in each segment
                            discover_changed_paths=True)
                        if self.rev is None:
                            if not self.quiet:
                                stderr.write("(none)")
                            break
                        if not self.quiet:
                            stderr.write(format(self.rev))
                            stderr.flush()
                        
                        # Do not generate a Git commit from a simple
                        # unmodified branch copy
                        prefix = path.rstrip("/") + "/"
                        if not any(path.startswith(prefix) and path != prefix
                        for path in self.paths.keys()):
                            default = (None, None, None)
                            (_, src, _) = self.paths.get(path, default)
                            if src is not None:
                                continue
                        
                        print("commit refs/{}".format(git_ref),
                            file=self.dump)
                        
                        date = strptime(self.date[:19], "%Y-%m-%dT%H:%M:%S")
                        date = timegm(date)
                        
                        if author_map is None:
                            author = ("{0.author} <{0.author}@{0.uuid}>".
                                format(self))
                        else:
                            author = author_map[self.author]
                        
                        print("committer {} {} +0000".format(author, date),
                            file=self.dump)
                        
                        log = "{}\n\ngit-svn-id: {}{}@{} {}\n".format(
                            self.log, root, path.rstrip("/"), self.rev,
                            self.uuid)
                        print("data", len(log), file=self.dump)
                        self.dump.write(log)
                        print(file=self.dump)
                        
                        if (prev_rev is None and
                        self.rev > 1 and not log_new_path(self.paths, path)):
                            print("from", git_ref, file=self.dump)
                        
                        if prev_rev is not None and prev_url is not None:
                            # This is not the first exported revision, and
                            # the previous one was at a different branch
                            # location. Will have to diff the previous
                            # location against the current location. Have to
                            # switch root because the diff reporter does not
                            # accept link_path() on the top-level directory.
                            ra.reparent(prev_url)
                            url = prev_url
                        
                        if not self.quiet:
                            stderr.write(":")
                            stderr.flush()
                        editor = RevEditor(self)
                        
                        # Diff editor does not convey deletions when starting
                        # from scratch
                        if prev_rev is None:
                            dir = DirEditor(self)
                            for (file, (action, _, _)) in self.paths.items():
                                if (file.startswith(prefix) and
                                action in "DR"):
                                    dir.delete_entry(file[len(prefix):])
                        
                        reporter = ra.do_diff(self.rev, "", new_url, editor,
                            True, True, True)
                        
                        # Reporter.set_path(path, revision, start_empty)
                        if prev_rev is None:
                            reporter.set_path("", self.rev, True)
                        else:
                            reporter.set_path("", prev_rev, False)
                        reporter.finish()
                        # Assume the editor calls are all completed now
                        print(file=self.dump)
                        
                        prev_rev = self.rev
                        
                        # Last exported location is current location
                        prev_url = None
                
                # Save URL of last location that was exported
                if prev_rev is not None and prev_url is None:
                    prev_url = new_url
    
    def on_location(self, start, end, path):
        if path is None:
            return
        if not self.quiet:
            stderr.write("\n  /{}:{}-{}".format(path, start, end))
        self.locations.append((start - 1, end, path))
    
    def on_revision(self, paths, rev, props, children=False):
        self.paths = paths
        self.rev = rev
        self.date = props[PROP_REVISION_DATE]
        self.author = props.get(PROP_REVISION_AUTHOR, "(no author)")
        self.log = props[PROP_REVISION_LOG]

class Editor(object):
    def __init__(self, repo):
        self.repo = repo
    def close(self):
        pass
class RevEditor(Editor):
    def set_target_revision(self, rev):
        pass
    def open_root(self, base):
        return DirEditor(self.repo)
    def abort(self):
        pass

class NodeEditor(Editor):
    def change_prop(self, name, value):
        pass
class DirEditor(NodeEditor):
    def add_directory(self, path):
        if not self.repo.quiet:
            stderr.writelines(("\n  A ", path, "/"))
        return self
    def open_directory(self, path, base):
        if not self.repo.quiet:
            stderr.writelines(("\n  M ", path, "/"))
        return self
    def add_file(self, path):
        if not self.repo.quiet:
            stderr.writelines(("\n  A ", path))
        return FileEditor(path, bytes(), self.repo)
    def open_file(self, path, base):
        if not self.repo.quiet:
            stderr.writelines(("\n  M ", path))
        return FileEditor(path, self.repo.files[path], self.repo)
    def delete_entry(self, path, rev=None):
        if not self.repo.quiet:
            stderr.writelines(("\n  D ", path))
        print("D", path, file=self.repo.dump)

class FileEditor(NodeEditor):
    def __init__(self, path, sbuf, *args, **kw):
        NodeEditor.__init__(self, *args, **kw)
        self.path = path
        self.sbuf = sbuf
    
    def apply_textdelta(self, base_sum):
        return DeltaWindowHandler(self)

class DeltaWindowHandler(object):
    def __init__(self, editor):
        self.editor = editor
        self.target_chunks = list()
        self.target_len = 0
    
    def __call__(self, chunk):
        if chunk is None:
            self.editor.repo.dump.seek(0, SEEK_END)
            
            print("M 644 inline", self.editor.path,
                file=self.editor.repo.dump)
            print("data", self.target_len, file=self.editor.repo.dump)
            
            self.editor.repo.files[self.editor.path] = FileArray(
                self.editor.repo.dump, self.editor.repo.dump.tell(),
                self.target_len)
            for chunk in self.target_chunks:
                self.editor.repo.dump.write(chunk)
            
            print(file=self.editor.repo.dump)
        
        else:
            chunk = apply_txdelta_window(self.editor.sbuf, chunk)
            self.target_chunks.append(chunk)
            self.target_len += len(chunk)

def parse_svn_rev(rev):
    if rev.upper() == "HEAD":
        return INVALID_REVNUM
    return int(rev)

def log_new_path(changes, path):
    """See if a path has no prior history"""
    
    parent = len(path.rstrip("/"))
    while parent >= 0:
        change = changes.get(path[:parent] or "/")
        if change:
            (action, src, _) = change
            if src is not None:  # Copy with history
                return False
            if action in "AR":  # Add without history
                return True
        parent = path.rfind("/", 0, parent)
    else:  # Branch not copied
        return False

class FileArray(object):
    def __init__(self, file, pos, len):
        self.file = file
        self.pos = pos
        self.len = len
    def __getitem__(self, slice):
        return FileArray(self.file,
            self.pos + slice.start, slice.stop - slice.start)
    def __radd__(self, str):
        self.file.seek(self.pos)
        return str + self.file.read(self.len)
    def __repr__(self):
        return "{}({}, {}, {})".format(type(self).__name__,
            self.file, self.pos, self.len)

@contextmanager
def progresscontext(*args):
    stderr.writelines(args)
    stderr.flush()
    try:
        yield
    finally:
        print(file=stderr)

@contextmanager
def dummycontext(*pos, **kw):
    yield

if __name__ == "__main__":
    (summary, _) = splitdoc(main.__doc__)
    parser = argparse.ArgumentParser(description=summary)
    parser.add_argument("url", help="subversion URL")
    parser.add_argument("dump", help="fast import file")
    parser.add_argument("git_ref",
        help='should include everything that follows the "refs/" prefix')
    parser.add_argument("-r", "--revision", metavar="BASE:END",
        default="0:HEAD", help="""subversion revisions to look up (default:
        0:HEAD). If the branch begins before the revision range, the Git
        branch is assumed to exist.""")
    parser.add_argument("-A", "--authors-file", metavar="FILENAME", help=
        'file mapping Subversion user names to Git authors, like "git-svn"')
    parser.add_argument("--rewrite-root", metavar="URL",
        help="subversion URL to store in the metadata")
    parser.add_argument("-q", "--quiet", action="store_true",
        help="suppress progress messages")
    args = parser.parse_args()
    main(args.url, args.dump, args.git_ref, revision=args.revision,
        authors=args.authors_file, root=args.rewrite_root, quiet=args.quiet)
