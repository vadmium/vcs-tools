#! /usr/bin/env python2

"""Converter from Subversion to Git's "fast-import" format

The program is written to

* use Subversion's remote access protocol
* minimise traffic from the Subversion server by
    * skipping revisions that do not affect the branch
    * skipping paths that are outside the branch
    * requesting deltas rather than full copies of files where practical
* follow branch copies
* produce identical commits to "git-svn"
* be run incrementally

It does not

* handle or correlate multiple trunks, branches, or tags
* take account of any kind of Subversion merge tracking
* handle special kinds of files (symbolic links, executables)
* do anything with special Subversion file or revision properties
"""

from __future__ import print_function

from subvertpy.ra import (RemoteAccess, Auth, get_username_provider)
from subvertpy.delta import apply_txdelta_window
from subvertpy.properties import (
    PROP_REVISION_DATE,
    PROP_REVISION_AUTHOR,
    PROP_REVISION_LOG,
)
from sys import (stderr, argv)
from functools import partial
from time import strptime
from calendar import timegm
from io import SEEK_END
from shorthand import fields
from shorthand import nop
from calltrace import tracer
from subvertpy import SubversionException
import argparse
from funcparams import splitdoc

INVALID_REVNUM = -1

def main(url, dump, git_ref,
revision="0:HEAD", authors=None, quiet=False):
    """Transform Subversion revisions to Git's "fast-import" format
    
    url  Subversion URL
    dump  Fast import file
    git_ref  Should include everything that follows the "refs/" prefix
    revision  Subversion revisions to look up; default: 0:HEAD. If the range
        does not begin at zero, the existing Git branch is assumed to match.
    authors  File mapping Subversion user names to Git authors, like "git-
        svn"
    quiet  Suppress progress messages
    """
    
    (base_rev, end_rev) = revision.split(":")
    base_rev = parse_svn_rev(base_rev)
    end_rev = parse_svn_rev(end_rev)
    if (base_rev == INVALID_REVNUM or
    end_rev != INVALID_REVNUM and end_rev < base_rev):
        (base_rev, end_rev) = (end_rev, base_rev)
    
    if authors is not None:
        author_map = dict()
        with open(authors, "rt") as file:
            for line in file:
                if line.endswith("\n"):
                    line = line[:-1]
                (svn, git) = line.split(" = ", 1)
                author_map[svn] = git
    
    repo = dict(files=dict(), quiet=quiet)
    uuid_url = True
    
    with open(dump, "w+b") as repo["dump"]:
        repo["dump"].tell()  # Make sure it is seekable
        
        # Auth stuff avoids the following error for diffs on local (file://)
        # URLs: "No provider registered for 'svn.username' credentials"
        auth = Auth((get_username_provider(),))
        
        if not repo["quiet"]:
            stderr.writelines(("connecting to ", url))
            stderr.flush()
        ra = RemoteAccess(url, auth=auth)
        if not repo["quiet"]:
            print(file=stderr)
        
        repos_root = ra.get_repos_root()
        branch = url[len(repos_root):]
        
        repo["uuid"] = ra.get_uuid()
        
        # If the log's starting revision is INVALID_REVNUM, Google Code seems
        # to look up the path in the log's ending revision, which fails if it
        # wasn't created then.
        if end_rev == INVALID_REVNUM:
            if not repo["quiet"]:
                stderr.write("HEAD: ")
                stderr.flush()
            end_rev = ra.get_latest_revnum()
            if not repo["quiet"]:
                print(end_rev, file=stderr)
        
        if end_rev == base_rev:
            # Degenerate case because no revisions are actually in the
            # range, but the log call would do a forwards log from
            # revision N to N + 1.
            return
        
        log_iter = ra.iter_log(paths=None, start=end_rev, end=base_rev + 1,
            strict_node_history=False, discover_changed_paths=True)
        
        # TODO: use "get_location_segments" instead
        log = list()
        while True:
            if not repo["quiet"]:
                stderr.write("revision ")
                stderr.flush()
            try:
                (paths, rev, props, _) = next(log_iter)
            except SubversionException as err:
                (msg, _) = err.args
                if not repo["quiet"]:
                    print(file=stderr)
                raise SystemExit(msg)
            except StopIteration:
                if not repo["quiet"]:
                    print("(stopped)", file=stderr)
                break
            
            parent = len(branch)
            while True:
                try:
                    (_, src, _, _) = paths[branch[:parent]]
                except LookupError:
                    pass
                else:
                    new = branch
                    break
                
                try:
                    parent = branch.rindex("/", 0, parent)
                except ValueError:
                    new = None
                    break
            
            if new is None:
                if not repo["quiet"]:
                    print(rev, file=stderr)
            elif src is None:
                if not repo["quiet"]:
                    print("{}: beginning of {}".format(rev, new),
                        file=stderr)
            else:
                branch = src + branch[parent:]
                if not repo["quiet"]:
                    print("{}: copied from {}".format(rev, branch),
                        file=stderr)
                
                prefix = new + "/"
                if not any(path.startswith(prefix)
                for path in paths.keys()):
                    # This revision is a simple branch copy without any
                    # file changes. Do not generate a Git commit from it.
                    if log and log[-1]["new_branch"] is None:
                        log[-1]["new_branch"] = new
                    continue
            
            log.append(dict(
                rev=rev,
                date=props[PROP_REVISION_DATE],
                author=props.get(PROP_REVISION_AUTHOR, "(no author)"),
                log = props[PROP_REVISION_LOG],
                new_branch=new,
            ))
            
            if new is not None and src is None:
                break
        # Make sure the underlying log call has completed
        for _ in log_iter:
            pass
        
        if log and new is None and branch != "":
            log[-1]["new_branch"] = branch
        prev = dict(rev=0, new_branch="")
        url = repos_root
        
        for entry in reversed(log):
            if prev["new_branch"] is not None:
                if not repo["quiet"]:
                    path = url[len(repos_root):]
                    if not path:
                        path = "/"
                    stderr.writelines(("switching to ", path))
                    stderr.flush()
                ra.reparent(url)
                if not repo["quiet"]:
                    print(file=stderr)
            
            if entry["new_branch"] is not None:
                url = repos_root + entry["new_branch"]
            path = url[len(repos_root):]
            
            print("commit refs/{}".format(git_ref), file=repo["dump"])
            
            date = timegm(strptime(entry["date"][:19], "%Y-%m-%dT%H:%M:%S"))
            
            if authors is None:
                author = ("{author} <{author}@{uuid}>".
                    format(author=entry["author"], uuid=repo["uuid"]))
            else:
                author = author_map[entry[author]]
            
            print("committer {} {} +0000".format(author, date),
                file=repo["dump"])
            
            if uuid_url:
                log = "{}\n\ngit-svn-id: {}@{} {}\n".format(
                    entry["log"], path, entry["rev"], repo["uuid"])
            else:
                log = "{}\n\ngit-svn-id: {}@{} {}\n".format(
                    entry["log"], url, entry["rev"], repo["uuid"])
            print("data", len(log), file=repo["dump"])
            repo["dump"].write(log)
            print(file=repo["dump"])
            
            if not prev["rev"] and base_rev:
                print("from", git_ref, file=repo["dump"])
            
            if not repo["quiet"]:
                stderr.write("{}@{}".format(path, entry["rev"]))
                stderr.flush()
            reporter = ra.do_diff(entry["rev"], "", url, RevEditor(repo),
                True, True, True)
            
            if not repo["quiet"]:
                stderr.write(":")
                stderr.flush()
            reporter.set_path("", prev["rev"], False)
            reporter.finish()
            # Assume the editor calls are all completed now
            if not repo["quiet"]:
                print(file=stderr)
            
            print(file=repo["dump"])
            
            prev = entry

class Editor(object):
    def __init__(self, repo):
        self.repo = repo
    close = nop
class RevEditor(Editor):
    set_target_revision = nop
    def open_root(self, base):
        return DirEditor(self.repo)
    abort = tracer("abort")

class NodeEditor(Editor):
    change_prop = nop
class DirEditor(NodeEditor):
    def add_directory(self, path):
        if not self.repo["quiet"]:
            stderr.writelines(("\n  A ", path, "/"))
        return self
    def open_directory(self, path, base):
        if not self.repo["quiet"]:
            stderr.writelines(("\n  M ", path, "/"))
        return self
    def add_file(self, path):
        if not self.repo["quiet"]:
            stderr.writelines(("\n  A ", path))
        return FileEditor(path, bytes(), self.repo)
    def open_file(self, path, base):
        if not self.repo["quiet"]:
            stderr.writelines(("\n  M ", path))
        return FileEditor(path, self.repo["files"][path], self.repo)
    def delete_entry(self, path, rev):
        if not self.repo["quiet"]:
            stderr.writelines(("\n  D ", path))
        print("D", path, file=self.repo["dump"])

class FileEditor(NodeEditor):
    def __init__(self, path, sbuf, *args, **kw):
        NodeEditor.__init__(self, *args, **kw)
        self.path = path
        self.sbuf = sbuf
    
    def apply_textdelta(self, base_sum):
        return DeltaWindowHandler(self)

class DeltaWindowHandler(object):
    def __init__(self, editor):
        self.editor = editor
        self.target_chunks = list()
        self.target_len = 0
    
    #~ @partial(traced, abbrev={1})
    def __call__(self, chunk):
        if chunk is None:
            self.editor.repo["dump"].seek(0, SEEK_END)
            
            print("M 644 inline", self.editor.path,
                file=self.editor.repo["dump"])
            print("data", self.target_len, file=self.editor.repo["dump"])
            
            self.editor.repo["files"][self.editor.path] = FileArray(
                self.editor.repo["dump"], self.editor.repo["dump"].tell(),
                self.target_len)
            for chunk in self.target_chunks:
                self.editor.repo["dump"].write(chunk)
            
            print(file=self.editor.repo["dump"])
        
        else:
            chunk = apply_txdelta_window(self.editor.sbuf, chunk)
            self.target_chunks.append(chunk)
            self.target_len += len(chunk)

def parse_svn_rev(rev):
    if rev.upper() == "HEAD":
        return INVALID_REVNUM
    return int(rev)

class FileArray(object):
    def __init__(self, file, pos, len):
        self.file = file
        self.pos = pos
        self.len = len
    def __getitem__(self, slice):
        return FileArray(self.file,
            self.pos + slice.start, slice.stop - slice.start)
    #~ @partial(traced, abbrev={1, "return"})
    def __radd__(self, str):
        self.file.seek(self.pos)
        return str + self.file.read(self.len)
    def __repr__(self):
        return "{}({}, {}, {})".format(type(self).__name__,
            self.file, self.pos, self.len)

if __name__ == "__main__":
    (summary, _) = splitdoc(main.__doc__)
    parser = argparse.ArgumentParser(description=summary)
    parser.add_argument("url", help="subversion URL")
    parser.add_argument("dump", help="fast import file")
    parser.add_argument("git_ref",
        help='should include everything that follows the "refs/" prefix')
    parser.add_argument("-r", "--revision", metavar="BASE:END",
        default="0:HEAD", help="""subversion revisions to look up (default:
        0:HEAD). If the range does not begin at zero, the existing Git branch
        is assumed to match.""")
    parser.add_argument("-A", "--authors-file", metavar="FILENAME", help=
        'file mapping Subversion user names to Git authors, like "git-svn"')
    parser.add_argument("-q", "--quiet", action="store_true",
        help="suppress progress messages")
    args = parser.parse_args()
    main(args.url, args.dump, args.git_ref, revision=args.revision,
        authors=args.authors_file, quiet=args.quiet)
